# run with: god -c /path/to/file.god -D
RAILS_ROOT = "<%= latest_release %>"
RAILS_ENV = "production"
SHARED_PATH = "<%= shared_path %>"
USER = "<%= user %>"
GROUP = "<%= user %>"
RUBY_PATH = "/home/passenger/.rbenv/bin"
GOD_ENVIRONMENT = {
  'RAILS_ROOT' => RAILS_ROOT,
  'RAILS_ENV' => RAILS_ENV,
  'PATH' => "#{RUBY_PATH}:/usr/bin:/bin"
}

# Redis
# see http://stackoverflow.com/questions/5822097/monitoring-redis-with-god-monitoring-conditions
# God.watch do |w|
#   w.name = "redis-server"
#   w.interval = 30.seconds
#   w.start = "/etc/init.d/redis-server start"
#   w.stop = "/etc/init.d/redis-server stop"
#   w.restart = "/etc/init.d/redis-server restart"
#   w.start_grace = 10.seconds
#   w.restart_grace = 10.seconds
# 
#   # determine the state on startup
#   w.transition(:init, { true => :up, false => :start }) do |on|
#     on.condition(:process_running) do |c|
#       c.running = true
#     end
#   end
#   
#   # start if process is not running
#   w.transition(:up, :start) do |on|
#     on.condition(:process_running) do |c|
#       c.running = false
#     end
#   end
#   
#   # restart if lost
#   w.start_if do |start|
#     start.condition(:process_running) do |c|
#       c.interval = 20.seconds
#       c.running = false
#     end
#   end
# end

# JUGGERNAUT
# see https://gist.github.com/1055322
JUGGERNAUT_PID = "#{SHARED_PATH}/pids/juggernaut.pid"
JUGGERNAUT_DAEMON = "/usr/bin/juggernaut"
JUGGERNAUT_PORT = "9001"
God.watch do |w|
  w.name = "juggernaut"
  w.interval = 20
  w.start = "start-stop-daemon --start --quiet --umask 007 --pidfile #{JUGGERNAUT_PID} --exec #{JUGGERNAUT_DAEMON} -- --port #{JUGGERNAUT_PORT}"
  w.stop = "start-stop-daemon --stop --retry 10 --quiet --oknodo --pidfile #{JUGGERNAUT_PID} --exec #{JUGGERNAUT_DAEMON} -- --port #{JUGGERNAUT_PORT}"
  w.start_grace = 10.seconds
  w.restart_grace = 10.seconds
  w.pid_file = JUGGERNAUT_PID
  
  # determine the state on startup
  w.transition(:init, { true => :up, false => :start }) do |on|
    on.condition(:process_running) do |c|
      c.running = true
    end
  end
  
  # start if process is not running
  w.transition(:up, :start) do |on|
    on.condition(:process_running) do |c|
      c.running = false
    end
  end
  
  # restart if lost
  w.start_if do |start|
    start.condition(:process_running) do |c|
      c.interval = 20.seconds
      c.running = false
    end
  end
end

# RESQUE WORKERS
# see https://github.com/defunkt/resque/blob/master/examples/god/resque.god
num_workers = RAILS_ENV == 'production' ? 1 : 1
num_workers.times do |num|
  God.watch do |w|
    w.uid = "#{USER}"
    w.gid = "#{GROUP}"
    
    w.dir      = RAILS_ROOT
    w.name     = "resque-#{num}"
    w.group    = 'resque'
    w.interval = 30.seconds
    w.env      = {"QUEUE"=>"*", "RAILS_ENV"=>RAILS_ENV}
    w.start    = "/home/passenger/.rbenv/bin/rbenv init && cd #{RAILS_ROOT} && bundle exec rake environment resque:work"
    w.log      = "#{SHARED_PATH}/log/resque_god.log"

    # restart if memory gets too high
    w.transition(:up, :restart) do |on|
      on.condition(:memory_usage) do |c|
        c.above = 350.megabytes
        c.times = 2
      end
    end

    # determine the state on startup
    w.transition(:init, { true => :up, false => :start }) do |on|
      on.condition(:process_running) do |c|
        c.running = true
      end
    end

    # determine when process has finished starting
    w.transition([:start, :restart], :up) do |on|
      on.condition(:process_running) do |c|
        c.running = true
        c.interval = 30.seconds
      end

      # failsafe
      on.condition(:tries) do |c|
        c.times = 3
        c.transition = :start
        c.interval = 30.seconds
      end
    end

    # start if process is not running
    w.transition(:up, :start) do |on|
      on.condition(:process_running) do |c|
        c.running = false
      end
    end
  end
end